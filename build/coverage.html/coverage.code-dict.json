{"/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/test.js":"/* istanbul instrument in package npmtest_cordova_plugin_file_transfer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/lib.npmtest_cordova_plugin_file_transfer.js":"/* istanbul instrument in package npmtest_cordova_plugin_file_transfer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugin_file_transfer = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugin_file_transfer = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-plugin-file-transfer && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugin_file_transfer */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugin_file_transfer\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugin_file_transfer.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_plugin_file_transfer.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugin_file_transfer.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_plugin_file_transfer.__dirname + '/lib.npmtest_cordova_plugin_file_transfer.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/FileTransferError.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/**\n * FileTransferError\n * @constructor\n */\nvar FileTransferError = function(code, source, target, status, body, exception) {\n    this.code = code || null;\n    this.source = source || null;\n    this.target = target || null;\n    this.http_status = status || null;\n    this.body = body || null;\n    this.exception = exception || null;\n};\n\nFileTransferError.FILE_NOT_FOUND_ERR = 1;\nFileTransferError.INVALID_URL_ERR = 2;\nFileTransferError.CONNECTION_ERR = 3;\nFileTransferError.ABORT_ERR = 4;\nFileTransferError.NOT_MODIFIED_ERR = 5;\n\nmodule.exports = FileTransferError;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/FileTransfer.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* global cordova, FileSystem */\n\nvar argscheck = require('cordova/argscheck'),\n    exec = require('cordova/exec'),\n    FileTransferError = require('./FileTransferError'),\n    ProgressEvent = require('cordova-plugin-file.ProgressEvent');\n\nfunction newProgressEvent(result) {\n    var pe = new ProgressEvent();\n    pe.lengthComputable = result.lengthComputable;\n    pe.loaded = result.loaded;\n    pe.total = result.total;\n    return pe;\n}\n\nfunction getUrlCredentials(urlString) {\n    var credentialsPattern = /^https?\\:\\/\\/(?:(?:(([^:@\\/]*)(?::([^@\\/]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?).*$/,\n        credentials = credentialsPattern.exec(urlString);\n\n    return credentials && credentials[1];\n}\n\nfunction getBasicAuthHeader(urlString) {\n    var header =  null;\n\n\n    // This is changed due to MS Windows doesn't support credentials in http uris\n    // so we detect them by regexp and strip off from result url\n    // Proof: http://social.msdn.microsoft.com/Forums/windowsapps/en-US/a327cf3c-f033-4a54-8b7f-03c56ba3203f/windows-foundation-uri-security-problem\n\n    if (window.btoa) {\n        var credentials = getUrlCredentials(urlString);\n        if (credentials) {\n            var authHeader = \"Authorization\";\n            var authHeaderValue = \"Basic \" + window.btoa(credentials);\n\n            header = {\n                name : authHeader,\n                value : authHeaderValue\n            };\n        }\n    }\n\n    return header;\n}\n\nfunction convertHeadersToArray(headers) {\n    var result = [];\n    for (var header in headers) {\n        if (headers.hasOwnProperty(header)) {\n            var headerValue = headers[header];\n            result.push({\n                name: header,\n                value: headerValue.toString()\n            });\n        }\n    }\n    return result;\n}\n\nvar idCounter = 0;\n\n/**\n * FileTransfer uploads a file to a remote server.\n * @constructor\n */\nvar FileTransfer = function() {\n    this._id = ++idCounter;\n    this.onprogress = null; // optional callback\n};\n\n/**\n* Given an absolute file path, uploads a file on the device to a remote server\n* using a multipart HTTP request.\n* @param filePath {String}           Full path of the file on the device\n* @param server {String}             URL of the server to receive the file\n* @param successCallback (Function}  Callback to be invoked when upload has completed\n* @param errorCallback {Function}    Callback to be invoked upon error\n* @param options {FileUploadOptions} Optional parameters such as file name and mimetype\n* @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n*/\nFileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {\n    argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);\n    // check for options\n    var fileKey = null;\n    var fileName = null;\n    var mimeType = null;\n    var params = null;\n    var chunkedMode = true;\n    var headers = null;\n    var httpMethod = null;\n    var basicAuthHeader = getBasicAuthHeader(server);\n    if (basicAuthHeader) {\n        server = server.replace(getUrlCredentials(server) + '@', '');\n\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    if (options) {\n        fileKey = options.fileKey;\n        fileName = options.fileName;\n        mimeType = options.mimeType;\n        headers = options.headers;\n        httpMethod = options.httpMethod || \"POST\";\n        if (httpMethod.toUpperCase() == \"PUT\"){\n            httpMethod = \"PUT\";\n        } else {\n            httpMethod = \"POST\";\n        }\n        if (options.chunkedMode !== null || typeof options.chunkedMode != \"undefined\") {\n            chunkedMode = options.chunkedMode;\n        }\n        if (options.params) {\n            params = options.params;\n        }\n        else {\n            params = {};\n        }\n    }\n\n    if (cordova.platformId === \"windowsphone\") {\n        headers = headers && convertHeadersToArray(headers);\n        params = params && convertHeadersToArray(params);\n    }\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body, e.exception);\n        errorCallback(error);\n    };\n\n    var self = this;\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                self.onprogress(newProgressEvent(result));\n            }\n        } else {\n            if (successCallback) {\n                successCallback(result);\n            }\n        }\n    };\n    exec(win, fail, 'FileTransfer', 'upload', [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id, httpMethod]);\n};\n\n/**\n * Downloads a file form a given URL and saves it to the specified directory.\n * @param source {String}          URL of the server to receive the file\n * @param target {String}         Full path of the file on the device\n * @param successCallback (Function}  Callback to be invoked when upload has completed\n * @param errorCallback {Function}    Callback to be invoked upon error\n * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n * @param options {FileDownloadOptions} Optional parameters such as headers\n */\nFileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts, options) {\n    argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);\n    var self = this;\n\n    var basicAuthHeader = getBasicAuthHeader(source);\n    if (basicAuthHeader) {\n        source = source.replace(getUrlCredentials(source) + '@', '');\n\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    var headers = null;\n    if (options) {\n        headers = options.headers || null;\n    }\n\n    if (cordova.platformId === \"windowsphone\" && headers) {\n        headers = convertHeadersToArray(headers);\n    }\n\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                return self.onprogress(newProgressEvent(result));\n            }\n        } else if (successCallback) {\n            var entry = null;\n            if (result.isDirectory) {\n                entry = new (require('cordova-plugin-file.DirectoryEntry'))();\n            }\n            else if (result.isFile) {\n                entry = new (require('cordova-plugin-file.FileEntry'))();\n            }\n            entry.isDirectory = result.isDirectory;\n            entry.isFile = result.isFile;\n            entry.name = result.name;\n            entry.fullPath = result.fullPath;\n            entry.filesystem = new FileSystem(result.filesystemName || (result.filesystem == window.PERSISTENT ? 'persistent' : 'temporary'));\n            entry.nativeURL = result.nativeURL;\n            successCallback(entry);\n        }\n    };\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body, e.exception);\n        errorCallback(error);\n    };\n\n    exec(win, fail, 'FileTransfer', 'download', [source, target, trustAllHosts, this._id, headers]);\n};\n\n/**\n * Aborts the ongoing file transfer on this object. The original error\n * callback for the file transfer will be called if necessary.\n */\nFileTransfer.prototype.abort = function() {\n    exec(null, null, 'FileTransfer', 'abort', [this._id]);\n};\n\nmodule.exports = FileTransfer;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/src/windows/FileTransferProxy.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*jshint -W030 */\n/*global Windows, WinJS*/\n/*global module, require*/\n\nvar FTErr = require('./FileTransferError'),\n    ProgressEvent = require('cordova-plugin-file.ProgressEvent'),\n    FileUploadResult = require('cordova-plugin-file.FileUploadResult'),\n    FileProxy = require('cordova-plugin-file.FileProxy');\n\nvar appData = Windows.Storage.ApplicationData.current;\n\nvar LINE_START = \"--\";\nvar LINE_END = \"\\r\\n\";\nvar BOUNDARY = '+++++';\n\nvar fileTransferOps = [];\n\n// Some private helper functions, hidden by the module\nfunction cordovaPathToNative(path) {\n\n    var cleanPath = String(path);\n    // turn / into \\\\\n    cleanPath = cleanPath.replace(/\\//g, '\\\\');\n    // turn  \\\\ into \\\n    cleanPath = cleanPath.replace(/\\\\\\\\/g, '\\\\');\n    // strip end \\\\ characters\n    cleanPath = cleanPath.replace(/\\\\+$/g, '');\n    return cleanPath;\n}\n\nfunction nativePathToCordova(path) {\n    return String(path).replace(/\\\\/g, '/');\n}\n\nfunction alreadyCancelled(opId) {\n    var op = fileTransferOps[opId];\n    return op && op.state === FileTransferOperation.CANCELLED;\n}\n\nfunction doUpload (upload, uploadId, filePath, server, successCallback, errorCallback) {\n    if (alreadyCancelled(uploadId)) {\n        errorCallback(new FTErr(FTErr.ABORT_ERR, nativePathToCordova(filePath), server));\n        return;\n    }\n\n    // update internal TransferOperation object with newly created promise\n    var uploadOperation = upload.startAsync();\n    fileTransferOps[uploadId].promise = uploadOperation;\n\n    uploadOperation.then(\n        function (result) {\n            // Update TransferOperation object with new state, delete promise property\n            // since it is not actual anymore\n            var currentUploadOp = fileTransferOps[uploadId];\n            if (currentUploadOp) {\n                currentUploadOp.state = FileTransferOperation.DONE;\n                currentUploadOp.promise = null;\n            }\n\n            var response = result.getResponseInformation();\n            var ftResult = new FileUploadResult(result.progress.bytesSent, response.statusCode, '');\n\n            // if server's response doesn't contain any data, then resolve operation now\n            if (result.progress.bytesReceived === 0) {\n                successCallback(ftResult);\n                return;\n            }\n\n            // otherwise create a data reader, attached to response stream to get server's response\n            var reader = new Windows.Storage.Streams.DataReader(result.getResultStreamAt(0));\n            reader.loadAsync(result.progress.bytesReceived).then(function (size) {\n                ftResult.response = reader.readString(size);\n                successCallback(ftResult);\n                reader.close();\n            });\n        },\n        function (error) {\n            var source = nativePathToCordova(filePath);\n\n            // Handle download error here.\n            // Wrap this routines into promise due to some async methods\n            var getTransferError = new WinJS.Promise(function (resolve) {\n                if (error.message === 'Canceled') {\n                    // If download was cancelled, message property will be specified\n                    resolve(new FTErr(FTErr.ABORT_ERR, source, server, null, null, error));\n                } else {\n                    // in the other way, try to get response property\n                    var response = upload.getResponseInformation();\n                    if (!response) {\n                        resolve(new FTErr(FTErr.CONNECTION_ERR, source, server));\n                    } else {\n                        var reader = new Windows.Storage.Streams.DataReader(upload.getResultStreamAt(0));\n                        reader.loadAsync(upload.progress.bytesReceived).then(function (size) {\n                            var responseText = reader.readString(size);\n                            resolve(new FTErr(FTErr.FILE_NOT_FOUND_ERR, source, server, response.statusCode, responseText, error));\n                            reader.close();\n                        });\n                    }\n                }\n            });\n\n            // Update TransferOperation object with new state, delete promise property\n            // since it is not actual anymore\n            var currentUploadOp = fileTransferOps[uploadId];\n            if (currentUploadOp) {\n                currentUploadOp.state = FileTransferOperation.CANCELLED;\n                currentUploadOp.promise = null;\n            }\n\n            // Report the upload error back\n            getTransferError.then(function (transferError) {\n                errorCallback(transferError);\n            });\n        },\n        function (evt) {\n            var progressEvent = new ProgressEvent('progress', {\n                loaded: evt.progress.bytesSent,\n                total: evt.progress.totalBytesToSend,\n                target: evt.resultFile\n            });\n            progressEvent.lengthComputable = true;\n            successCallback(progressEvent, { keepCallback: true });\n        }\n    );\n}\n\nfunction FileTransferOperation(state, promise) {\n    this.state = state;\n    this.promise = promise;\n}\n\nFileTransferOperation.PENDING = 0;\nFileTransferOperation.DONE = 1;\nFileTransferOperation.CANCELLED = 2;\n\nvar HTTP_E_STATUS_NOT_MODIFIED = -2145844944;\n\nmodule.exports = {\n\n/*\nexec(win, fail, 'FileTransfer', 'upload', \n[filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id, httpMethod]);\n*/\n    upload: function (successCallback, errorCallback, options) {\n        var filePath = options[0];\n        var server = options[1];\n        var fileKey = options[2] || 'source';\n        var fileName = options[3];\n        var mimeType = options[4];\n        var params = options[5];\n        // var trustAllHosts = options[6]; // todo\n        // var chunkedMode = options[7]; // todo \n        var headers = options[8] || {};\n        var uploadId = options[9];\n        var httpMethod = options[10];\n\n        var isMultipart = typeof headers[\"Content-Type\"] === 'undefined';\n\n        function stringToByteArray(str) {\n            var byteCharacters = atob(str);\n            var byteNumbers = new Array(byteCharacters.length);\n            for (var i = 0; i < byteCharacters.length; i++) {\n                byteNumbers[i] = byteCharacters.charCodeAt(i);\n            }\n            return new Uint8Array(byteNumbers);\n        }\n\n        if (!filePath || (typeof filePath !== 'string')) {\n            errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR, null, server));\n            return;\n        }\n\n        if (filePath.indexOf(\"data:\") === 0 && filePath.indexOf(\"base64\") !== -1) {\n            // First a DataWriter object is created, backed by an in-memory stream where \n            // the data will be stored.\n            var writer = Windows.Storage.Streams.DataWriter(new Windows.Storage.Streams.InMemoryRandomAccessStream());\n            writer.unicodeEncoding = Windows.Storage.Streams.UnicodeEncoding.utf8;\n            writer.byteOrder = Windows.Storage.Streams.ByteOrder.littleEndian;\n\n            var commaIndex = filePath.indexOf(\",\");\n            if (commaIndex === -1) {\n                errorCallback(new FTErr(FTErr.INVALID_URL_ERR, fileName, server, null, null, \"No comma in data: URI\"));\n                return;\n            }\n\n            // Create internal download operation object\n            fileTransferOps[uploadId] = new FileTransferOperation(FileTransferOperation.PENDING, null);\n\n            var fileDataString = filePath.substr(commaIndex + 1);\n\n            // setting request headers for uploader\n            var uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();\n            uploader.method = httpMethod;\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)) {\n                    uploader.setRequestHeader(header, headers[header]);\n                }\n            }\n\n            if (isMultipart) {\n                // adding params supplied to request payload\n                var multipartParams = '';\n                for (var key in params) {\n                    if (params.hasOwnProperty(key)) {\n                        multipartParams += LINE_START + BOUNDARY + LINE_END;\n                        multipartParams += \"Content-Disposition: form-data; name=\\\"\" + key + \"\\\"\";\n                        multipartParams += LINE_END + LINE_END;\n                        multipartParams += params[key];\n                        multipartParams += LINE_END;\n                    }\n                }\n\n                var multipartFile = LINE_START + BOUNDARY + LINE_END;\n                multipartFile += \"Content-Disposition: form-data; name=\\\"file\\\";\";\n                multipartFile += \" filename=\\\"\" + fileName + \"\\\"\" + LINE_END;\n                multipartFile += \"Content-Type: \" + mimeType + LINE_END + LINE_END;\n\n                var bound = LINE_END + LINE_START + BOUNDARY + LINE_START + LINE_END;\n\n                uploader.setRequestHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n                writer.writeString(multipartParams);\n                writer.writeString(multipartFile);\n                writer.writeBytes(stringToByteArray(fileDataString));\n                writer.writeString(bound);\n            } else {\n                writer.writeBytes(stringToByteArray(fileDataString));\n            }\n\n            var stream;\n\n            // The call to store async sends the actual contents of the writer \n            // to the backing stream.\n            writer.storeAsync().then(function () {\n                // For the in-memory stream implementation we are using, the flushAsync call \n                // is superfluous, but other types of streams may require it.\n                return writer.flushAsync();\n            }).then(function () {\n                // We detach the stream to prolong its useful lifetime. Were we to fail \n                // to detach the stream, the call to writer.close() would close the underlying \n                // stream, preventing its subsequent use by the DataReader below. Most clients \n                // of DataWriter will have no reason to use the underlying stream after \n                // writer.close() is called, and will therefore have no reason to call\n                // writer.detachStream(). Note that once we detach the stream, we assume \n                // responsibility for closing the stream subsequently; after the stream \n                // has been detached, a call to writer.close() will have no effect on the stream.\n                stream = writer.detachStream();\n                // Make sure the stream is read from the beginning in the reader \n                // we are creating below.\n                stream.seek(0);\n                // Most DataWriter clients will not call writer.detachStream(), \n                // and furthermore will be working with a file-backed or network-backed stream, \n                // rather than an in-memory-stream. In such cases, it would be particularly \n                // important to call writer.close(). Doing so is always a best practice.\n                writer.close();\n\n                if (alreadyCancelled(uploadId)) {\n                    errorCallback(new FTErr(FTErr.ABORT_ERR, nativePathToCordova(filePath), server));\n                    return;\n                }\n\n                // create download object. This will throw an exception if URL is malformed\n                var uri = new Windows.Foundation.Uri(server);\n\n                var createUploadOperation;\n                try {\n                    createUploadOperation = uploader.createUploadFromStreamAsync(uri, stream);\n                } catch (e) {\n                    errorCallback(new FTErr(FTErr.INVALID_URL_ERR));\n                    return;\n                }\n\n                createUploadOperation.then(\n                    function (upload) {\n                        doUpload(upload, uploadId, filePath, server, successCallback, errorCallback);\n                    },\n                    function (err) {\n                        var errorObj = new FTErr(FTErr.INVALID_URL_ERR);\n                        errorObj.exception = err;\n                        errorCallback(errorObj);\n                    });\n            });\n\n            return;\n        }\n\n        if (filePath.substr(0, 8) === \"file:///\") {\n            filePath = appData.localFolder.path + filePath.substr(8).split(\"/\").join(\"\\\\\");\n        } else if (filePath.indexOf('ms-appdata:///') === 0) {\n            // Handle 'ms-appdata' scheme\n            filePath = filePath.replace('ms-appdata:///local', appData.localFolder.path)\n                               .replace('ms-appdata:///temp', appData.temporaryFolder.path);\n        } else if (filePath.indexOf('cdvfile://') === 0) {\n            filePath = filePath.replace('cdvfile://localhost/persistent', appData.localFolder.path)\n                               .replace('cdvfile://localhost/temporary', appData.temporaryFolder.path);\n        }\n\n        // normalize path separators\n        filePath = cordovaPathToNative(filePath);\n\n        // Create internal download operation object\n        fileTransferOps[uploadId] = new FileTransferOperation(FileTransferOperation.PENDING, null);\n\n        Windows.Storage.StorageFile.getFileFromPathAsync(filePath)\n        .then(function (storageFile) {\n\n            if (!fileName) {\n                fileName = storageFile.name;\n            }\n            if (!mimeType) {\n                // use the actual content type of the file, probably this should be the default way.\n                // other platforms probably can't look this up.\n                mimeType = storageFile.contentType;\n            }\n\n            if (alreadyCancelled(uploadId)) {\n                errorCallback(new FTErr(FTErr.ABORT_ERR, nativePathToCordova(filePath), server));\n                return;\n            }\n\n            // setting request headers for uploader\n            var uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();\n            uploader.method = httpMethod;\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)) {\n                    uploader.setRequestHeader(header, headers[header]);\n                }\n            }\n\n            // create download object. This will throw an exception if URL is malformed\n            var uri = new Windows.Foundation.Uri(server);\n\n            var createUploadOperation;\n            try {\n                if (isMultipart) {\n                    // adding params supplied to request payload\n                    var transferParts = [];\n                    for (var key in params) {\n                        // Create content part for params only if value is specified because CreateUploadAsync fails otherwise\n                        if (params.hasOwnProperty(key) && params[key] !== null && params[key] !== undefined && params[key].toString() !== \"\") {\n                            var contentPart = new Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart();\n                            contentPart.setHeader(\"Content-Disposition\", \"form-data; name=\\\"\" + key + \"\\\"\");\n                            contentPart.setText(params[key]);\n                            transferParts.push(contentPart);\n                        }\n                    }\n\n                    // Adding file to upload to request payload\n                    var fileToUploadPart = new Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart(fileKey, fileName);\n                    fileToUploadPart.setHeader(\"Content-Type\", mimeType);\n                    fileToUploadPart.setFile(storageFile);\n                    transferParts.push(fileToUploadPart);\n\n                    createUploadOperation = uploader.createUploadAsync(uri, transferParts);\n                } else {\n                    createUploadOperation = WinJS.Promise.wrap(uploader.createUpload(uri, storageFile));\n                }\n            } catch (e) {\n                errorCallback(new FTErr(FTErr.INVALID_URL_ERR));\n                return;\n            }\n\n            createUploadOperation.then(\n                function (upload) {\n                    doUpload(upload, uploadId, filePath, server, successCallback, errorCallback);\n                },\n                function (err) {\n                    var errorObj = new FTErr(FTErr.INVALID_URL_ERR);\n                    errorObj.exception = err;\n                    errorCallback(errorObj);\n                }\n            );\n        }, function (err) {\n            errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR, fileName, server, null, null, err));\n        });\n    },\n\n    // [source, target, trustAllHosts, id, headers]\n    download:function(successCallback, errorCallback, options) {\n        var source = options[0];\n        var target = options[1];\n        var downloadId = options[3];\n        var headers = options[4] || {};\n\n        if (!target) {\n            errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR));\n            return;\n        }\n        if (target.substr(0, 8) === \"file:///\") {\n            target = appData.localFolder.path + target.substr(8).split(\"/\").join(\"\\\\\");\n        } else if (target.indexOf('ms-appdata:///') === 0) {\n            // Handle 'ms-appdata' scheme\n            target = target.replace('ms-appdata:///local', appData.localFolder.path)\n                           .replace('ms-appdata:///temp', appData.temporaryFolder.path);\n        } else if (target.indexOf('cdvfile://') === 0) {\n            target = target.replace('cdvfile://localhost/persistent', appData.localFolder.path)\n                           .replace('cdvfile://localhost/temporary', appData.temporaryFolder.path);\n        }\n        target = cordovaPathToNative(target);\n\n        var path = target.substr(0, target.lastIndexOf(\"\\\\\"));\n        var fileName = target.substr(target.lastIndexOf(\"\\\\\") + 1);\n        if (path === null || fileName === null) {\n            errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR));\n            return;\n        }\n        // Download to a temp file to avoid the file deletion on 304 \n        // CB-7006 Empty file is created on file transfer if server response is 304\n        var tempFileName = '~' + fileName;\n\n        var download = null;\n\n        // Create internal download operation object\n        fileTransferOps[downloadId] = new FileTransferOperation(FileTransferOperation.PENDING, null);\n\n        var downloadCallback = function(storageFolder) {\n            storageFolder.createFileAsync(tempFileName, Windows.Storage.CreationCollisionOption.replaceExisting).then(function (storageFile) {\n\n                if (alreadyCancelled(downloadId)) {\n                    errorCallback(new FTErr(FTErr.ABORT_ERR, source, target));\n                    return;\n                }\n\n                // if download isn't cancelled, contunue with creating and preparing download operation\n                var downloader = new Windows.Networking.BackgroundTransfer.BackgroundDownloader();\n                for (var header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        downloader.setRequestHeader(header, headers[header]);\n                    }\n                }\n\n                // create download object. This will throw an exception if URL is malformed\n                try {\n                    var uri = Windows.Foundation.Uri(source);\n                    download = downloader.createDownload(uri, storageFile);\n                } catch (e) {\n                    // so we handle this and call errorCallback\n                    errorCallback(new FTErr(FTErr.INVALID_URL_ERR));\n                    return;\n                }\n\n                var downloadOperation = download.startAsync();\n                // update internal TransferOperation object with newly created promise\n                fileTransferOps[downloadId].promise = downloadOperation;\n\n                downloadOperation.then(function () {\n\n                    // Update TransferOperation object with new state, delete promise property\n                    // since it is not actual anymore\n                    var currentDownloadOp = fileTransferOps[downloadId];\n                    if (currentDownloadOp) {\n                        currentDownloadOp.state = FileTransferOperation.DONE;\n                        currentDownloadOp.promise = null;\n                    }\n\n                    storageFile.renameAsync(fileName, Windows.Storage.CreationCollisionOption.replaceExisting).done(function () {\n                        var nativeURI = storageFile.path.replace(appData.localFolder.path, 'ms-appdata:///local')\n                        .replace(appData.temporaryFolder.path, 'ms-appdata:///temp')\n                        .replace(/\\\\/g, '/');\n\n                        // Passing null as error callback here because downloaded file should exist in any case\n                        // otherwise the error callback will be hit during file creation in another place\n                        FileProxy.resolveLocalFileSystemURI(successCallback, null, [nativeURI]);\n                    }, function(error) {\n                        errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR, source, target, null, null, error));\n                    });\n                }, function(error) {\n\n                    var getTransferError = new WinJS.Promise(function (resolve) {\n                        // Handle download error here. If download was cancelled,\n                        // message property will be specified\n                        if (error.message === 'Canceled') {\n                            resolve(new FTErr(FTErr.ABORT_ERR, source, target, null, null, error));\n                        } else if (error && error.number === HTTP_E_STATUS_NOT_MODIFIED) {\n                            resolve(new FTErr(FTErr.NOT_MODIFIED_ERR, source, target, 304, null, error));\n                        } else {\n                            // in the other way, try to get response property\n                            var response = download.getResponseInformation();\n                            if (!response) {\n                                resolve(new FTErr(FTErr.CONNECTION_ERR, source, target));\n                            } else {\n                                var reader = new Windows.Storage.Streams.DataReader(download.getResultStreamAt(0));\n                                reader.loadAsync(download.progress.bytesReceived).then(function (bytesLoaded) {\n                                    var payload = reader.readString(bytesLoaded);\n                                    resolve(new FTErr(FTErr.FILE_NOT_FOUND_ERR, source, target, response.statusCode, payload, error));\n                                });\n                            }\n                        }\n                    });\n                    getTransferError.then(function (fileTransferError) {\n\n                        // Update TransferOperation object with new state, delete promise property\n                        // since it is not actual anymore\n                        var currentDownloadOp = fileTransferOps[downloadId];\n                        if (currentDownloadOp) {\n                            currentDownloadOp.state = FileTransferOperation.CANCELLED;\n                            currentDownloadOp.promise = null;\n                        }\n\n                        // Cleanup, remove incompleted file\n                        storageFile.deleteAsync().then(function() {\n                            errorCallback(fileTransferError);\n                        });\n                    });\n\n                }, function(evt) {\n\n                    var progressEvent = new ProgressEvent('progress', {\n                        loaded: evt.progress.bytesReceived,\n                        total: evt.progress.totalBytesToReceive,\n                        target: evt.resultFile\n                    });\n                    // when bytesReceived == 0, BackgroundDownloader has not yet differentiated whether it could get file length or not,\n                    // when totalBytesToReceive == 0, BackgroundDownloader is unable to get file length\n                    progressEvent.lengthComputable = (evt.progress.bytesReceived > 0) && (evt.progress.totalBytesToReceive > 0);\n\n                    successCallback(progressEvent, { keepCallback: true });\n                });\n            }, function(error) {\n                errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR, source, target, null, null, error));\n            });\n        };\n\n        var fileNotFoundErrorCallback = function(error) {\n            errorCallback(new FTErr(FTErr.FILE_NOT_FOUND_ERR, source, target, null, null, error));\n        };\n\n        Windows.Storage.StorageFolder.getFolderFromPathAsync(path).then(downloadCallback, function (error) {\n            // Handle non-existent directory\n            if (error.number === -2147024894) {\n                var parent = path.substr(0, path.lastIndexOf('\\\\')),\n                    folderNameToCreate = path.substr(path.lastIndexOf('\\\\') + 1);\n\n                Windows.Storage.StorageFolder.getFolderFromPathAsync(parent).then(function(parentFolder) {\n                    parentFolder.createFolderAsync(folderNameToCreate).then(downloadCallback, fileNotFoundErrorCallback);\n                }, fileNotFoundErrorCallback);\n            } else {\n                fileNotFoundErrorCallback();\n            }\n        });\n    },\n\n    abort: function (successCallback, error, options) {\n        var fileTransferOpId = options[0];\n\n        // Try to find transferOperation with id specified, and cancel its' promise\n        var currentOp = fileTransferOps[fileTransferOpId];\n        if (currentOp) {\n            currentOp.state = FileTransferOperation.CANCELLED;\n            currentOp.promise && currentOp.promise.cancel();\n        } else if (typeof fileTransferOpId !== 'undefined') {\n            // Create the operation in cancelled state to be aborted right away\n            fileTransferOps[fileTransferOpId] = new FileTransferOperation(FileTransferOperation.CANCELLED, null);\n        }\n    }\n\n};\n\nrequire(\"cordova/exec/proxy\").add(\"FileTransfer\",module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/blackberry10/FileTransfer.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar argscheck = require('cordova/argscheck'),\n    FileTransferError = require('./FileTransferError'),\n    xhrImpl = require('./BB10XHRImplementation');\n\n\nfunction getBasicAuthHeader(urlString) {\n    var header =  null;\n\n    if (window.btoa) {\n        // parse the url using the Location object\n        var url = document.createElement('a');\n        url.href = urlString;\n\n        var credentials = null;\n        var protocol = url.protocol + \"//\";\n        var origin = protocol + url.host;\n\n        // check whether there are the username:password credentials in the url\n        if (url.href.indexOf(origin) !== 0) { // credentials found\n            var atIndex = url.href.indexOf(\"@\");\n            credentials = url.href.substring(protocol.length, atIndex);\n        }\n\n        if (credentials) {\n            var authHeader = \"Authorization\";\n            var authHeaderValue = \"Basic \" + window.btoa(credentials);\n\n            header = {\n                name : authHeader,\n                value : authHeaderValue\n            };\n        }\n    }\n\n    return header;\n}\n\nvar idCounter = 0;\n\n/**\n * FileTransfer uploads a file to a remote server.\n * @constructor\n */\nvar FileTransfer = function() {\n    this._id = ++idCounter;\n    this.onprogress = null; // optional callback\n};\n\n/**\n* Given an absolute file path, uploads a file on the device to a remote server\n* using a multipart HTTP request.\n* @param filePath {String}           Full path of the file on the device\n* @param server {String}             URL of the server to receive the file\n* @param successCallback (Function}  Callback to be invoked when upload has completed\n* @param errorCallback {Function}    Callback to be invoked upon error\n* @param options {FileUploadOptions} Optional parameters such as file name and mimetype\n* @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n*/\nFileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options, trustAllHosts) {\n    argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);\n    // check for options\n    var fileKey = null;\n    var fileName = null;\n    var mimeType = null;\n    var params = null;\n    var chunkedMode = true;\n    var headers = null;\n    var httpMethod = null;\n    var basicAuthHeader = getBasicAuthHeader(server);\n    if (basicAuthHeader) {\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    if (options) {\n        fileKey = options.fileKey;\n        fileName = options.fileName;\n        mimeType = options.mimeType;\n        headers = options.headers;\n        httpMethod = options.httpMethod || \"POST\";\n        if (httpMethod.toUpperCase() == \"PUT\"){\n            httpMethod = \"PUT\";\n        } else {\n            httpMethod = \"POST\";\n        }\n        if (options.chunkedMode !== null || typeof options.chunkedMode != \"undefined\") {\n            chunkedMode = options.chunkedMode;\n        }\n        if (options.params) {\n            params = options.params;\n        }\n        else {\n            params = {};\n        }\n    }\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body);\n        errorCallback(error);\n    };\n\n    var self = this;\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                self.onprogress(result);\n            }\n        } else {\n            if (successCallback) {\n                successCallback(result);\n            }\n        }\n    };\n    xhrImpl.upload(win, fail, [filePath, server, fileKey, fileName, mimeType, params, trustAllHosts, chunkedMode, headers, this._id, httpMethod]);\n};\n\n/**\n * Downloads a file form a given URL and saves it to the specified directory.\n * @param source {String}          URL of the server to receive the file\n * @param target {String}         Full path of the file on the device\n * @param successCallback (Function}  Callback to be invoked when upload has completed\n * @param errorCallback {Function}    Callback to be invoked upon error\n * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n * @param options {FileDownloadOptions} Optional parameters such as headers\n */\nFileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts, options) {\n    argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);\n    var self = this;\n\n    var basicAuthHeader = getBasicAuthHeader(source);\n    if (basicAuthHeader) {\n        options = options || {};\n        options.headers = options.headers || {};\n        options.headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    var headers = null;\n    if (options) {\n        headers = options.headers || null;\n    }\n\n    var win = function(result) {\n        if (typeof result.lengthComputable != \"undefined\") {\n            if (self.onprogress) {\n                return self.onprogress(result);\n            }\n        } else if (successCallback) {\n            successCallback(result);\n        }\n    };\n\n    var fail = errorCallback && function(e) {\n        var error = new FileTransferError(e.code, e.source, e.target, e.http_status, e.body);\n        errorCallback(error);\n    };\n\n    xhrImpl.download(win, fail, [source, target, trustAllHosts, this._id, headers]);\n};\n\n/**\n * Aborts the ongoing file transfer on this object. The original error\n * callback for the file transfer will be called if necessary.\n */\nFileTransfer.prototype.abort = function() {\n    xhrImpl.abort(null, null, [this._id]);\n};\n\nmodule.exports = FileTransfer;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/blackberry10/FileTransferProxy.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*\n * FileTransferProxy\n *\n * Register all FileTransfer exec calls to be handled by proxy\n */\n\nvar xhrFileTransfer = require('cordova-plugin-file-transfer.xhrFileTransfer');\n\nmodule.exports = {\n    abort: xhrFileTransfer.abort,\n    download: xhrFileTransfer.download,\n    upload: xhrFileTransfer.upload\n};\n\nrequire('cordova/exec/proxy').add('FileTransfer', module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/blackberry10/xhrFileTransfer.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/* global Blob:false */\n\nvar cordova = require('cordova'),\n    resolve = cordova.require('cordova-plugin-file.resolveLocalFileSystemURIProxy'),\n    requestAnimationFrame = cordova.require('cordova-plugin-file.bb10RequestAnimationFrame'),\n    xhr = {};\n\nfunction getParentPath(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(0, pos + 1);\n}\n\nfunction getFileName(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(pos + 1);\n}\n\nfunction checkURL(url) {\n    return url.indexOf(' ') === -1 ?  true : false;\n}\n\nmodule.exports = {\n    abort: function (win, fail, args) {\n        var id = args[0];\n        if (xhr[id]) {\n            xhr[id].abort();\n            if (typeof(win) === 'function') {\n                win();\n            }\n        } else if (typeof(fail) === 'function') {\n            fail();\n        }\n    },\n\n    upload: function(win, fail, args) {\n        var filePath = args[0],\n            server = args[1],\n            fileKey = args[2],\n            fileName = args[3],\n            mimeType = args[4],\n            params = args[5],\n            /*trustAllHosts = args[6],*/\n            chunkedMode = args[7],\n            headers = args[8],\n            onSuccess = function (data) {\n                if (typeof(win) === 'function') {\n                    win(data);\n                }\n            },\n            onFail = function (code) {\n                delete xhr[fileKey];\n                if (typeof(fail) === 'function') {\n                    fail(code);\n                }\n            };\n\n        if (!checkURL(server)) {\n            onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, server, filePath));\n        }\n\n        xhr[fileKey] = new XMLHttpRequest();\n        xhr[fileKey].onabort = function () {\n            onFail(new FileTransferError(FileTransferError.ABORT_ERR, server, filePath, this.status, xhr[fileKey].response));\n        };\n\n        resolve(function(entry) {\n            requestAnimationFrame(function () {\n                entry.nativeEntry.file(function(file) {\n                    function uploadFile(blobFile) {\n                        var fd = new FormData();\n\n                        fd.append(fileKey, blobFile, fileName);\n                        for (var prop in params) {\n                            if(params.hasOwnProperty(prop)) {\n                                fd.append(prop, params[prop]);\n                            }\n                        }\n\n                        xhr[fileKey].open(\"POST\", server);\n                        xhr[fileKey].onload = function(evt) {\n                            if (xhr[fileKey].status === 200) {\n                                var result = new FileUploadResult();\n                                result.bytesSent = file.size;\n                                result.responseCode = xhr[fileKey].status;\n                                result.response = xhr[fileKey].response;\n                                delete xhr[fileKey];\n                                onSuccess(result);\n                            } else if (xhr[fileKey].status === 404) {\n                                onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                            } else {\n                                onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                            }\n                        };\n                        xhr[fileKey].ontimeout = function(evt) {\n                            onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                        };\n                        xhr[fileKey].onerror = function () {\n                            onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, this.status, xhr[fileKey].response));\n                        };\n                        xhr[fileKey].upload.onprogress = function (evt) {\n                            if (evt.loaded > 0) {\n                                onSuccess(evt);\n                            }\n                        };\n\n                        for (var header in headers) {\n                            if (headers.hasOwnProperty(header)) {\n                                xhr[fileKey].setRequestHeader(header, headers[header]);\n                            }\n                        }\n\n                        requestAnimationFrame(function () {\n                            xhr[fileKey].send(fd);\n                        });\n                    }\n\n                    var bytesPerChunk;\n                    if (chunkedMode === true) {\n                        bytesPerChunk = 1024 * 1024; // 1MB chunk sizes.\n                    } else {\n                        bytesPerChunk = file.size;\n                    }\n                    var start = 0;\n                    var end = bytesPerChunk;\n                    while (start < file.size) {\n                        var chunk = file.slice(start, end, mimeType);\n                        uploadFile(chunk);\n                        start = end;\n                        end = start + bytesPerChunk;\n                    }\n                }, function(error) {\n                    onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, server, filePath));\n                });\n            });\n        }, function(error) {\n            onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, server, filePath));\n        }, [filePath]);\n    },\n\n    download: function (win, fail, args) {\n        var source = args[0],\n            target = args[1],\n            id = args[3],\n            headers = args[4],\n            fileWriter,\n            onSuccess = function (entry) {\n                if (typeof(win) === 'function') {\n                    win(entry);\n                }\n            },\n            onFail = function (error) {\n                var reader;\n                delete xhr[id];\n                if (typeof(fail) === 'function') {\n                    if (error && error.body && typeof(error.body) === 'object') {\n                        reader = new FileReader()._realReader;\n                        reader.onloadend = function () {\n                            error.body = this.result;\n                            fail(error);\n                        };\n                        reader.onerror = function () {\n                            fail(error);\n                        };\n                        reader.readAsText(error.body);\n                    } else {\n                        fail(error);\n                    }\n                }\n            };\n\n        if (!checkURL(source)) {\n            onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, source, target));\n        }\n\n        xhr[id] = new XMLHttpRequest();\n\n        function writeFile(entry) {\n            entry.createWriter(function (writer) {\n                fileWriter = writer;\n                fileWriter.onwriteend = function (evt) {\n                    if (!evt.target.error) {\n                        entry.filesystemName = entry.filesystem.name;\n                        delete xhr[id];\n                        onSuccess(entry);\n                    } else {\n                        onFail(evt.target.error);\n                    }\n                };\n                fileWriter.onerror = function (evt) {\n                    onFail(evt.target.error);\n                };\n                fileWriter.write(new Blob([xhr[id].response]));\n            }, function (error) {\n                onFail(error);\n            });\n        }\n\n        xhr[id].onerror = function (e) {\n            onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, source, target, xhr[id].status, xhr[id].response));\n        };\n\n        xhr[id].onabort = function (e) {\n            onFail(new FileTransferError(FileTransferError.ABORT_ERR, source, target, xhr[id].status, xhr[id].response));\n        };\n\n        xhr[id].onload = function () {\n            if (xhr[id].readyState === xhr[id].DONE) {\n                if (xhr[id].status === 200 && xhr[id].response) {\n                    resolveLocalFileSystemURI(getParentPath(target), function (dir) {\n                        dir.getFile(getFileName(target), {create: true}, writeFile, function (error) {\n                            onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, source, target, xhr[id].status, xhr[id].response));\n                        });\n                    }, function (error) {\n                        onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, source, target, xhr[id].status, xhr[id].response));\n                    });\n                } else if (xhr[id].status === 404) {\n                    onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, source, target, xhr[id].status, xhr[id].response));\n                } else {\n                    onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, source, target, xhr[id].status, xhr[id].response));\n                }\n            }\n        };\n        xhr[id].onprogress = function (evt) {\n            onSuccess(evt);\n        };\n        xhr[id].open(\"GET\", source, true);\n        for (var header in headers) {\n            if (headers.hasOwnProperty(header)) {\n                xhr[id].setRequestHeader(header, headers[header]);\n            }\n        }\n        xhr[id].responseType = \"blob\";\n        requestAnimationFrame(function () {\n            if (xhr[id]) {\n                xhr[id].send();\n            }\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/browser/FileTransfer.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n/*global module, require*/\n\nvar argscheck = require('cordova/argscheck'),\n    FileTransferError = require('./FileTransferError');\n\nfunction getParentPath(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(0, pos + 1);\n}\n\nfunction getFileName(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(pos + 1);\n}\n\nfunction getUrlCredentials(urlString) {\n    var credentialsPattern = /^https?\\:\\/\\/(?:(?:(([^:@\\/]*)(?::([^@\\/]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?).*$/,\n        credentials = credentialsPattern.exec(urlString);\n\n    return credentials && credentials[1];\n}\n\nfunction getBasicAuthHeader(urlString) {\n    var header =  null;\n\n\n    // This is changed due to MS Windows doesn't support credentials in http uris\n    // so we detect them by regexp and strip off from result url\n    // Proof: http://social.msdn.microsoft.com/Forums/windowsapps/en-US/a327cf3c-f033-4a54-8b7f-03c56ba3203f/windows-foundation-uri-security-problem\n\n    if (window.btoa) {\n        var credentials = getUrlCredentials(urlString);\n        if (credentials) {\n            var authHeader = \"Authorization\";\n            var authHeaderValue = \"Basic \" + window.btoa(credentials);\n\n            header = {\n                name : authHeader,\n                value : authHeaderValue\n            };\n        }\n    }\n\n    return header;\n}\n\nfunction checkURL(url) {\n    return url.indexOf(' ') === -1 ?  true : false;\n}\n\nvar idCounter = 0;\n\nvar transfers = {};\n\n/**\n * FileTransfer uploads a file to a remote server.\n * @constructor\n */\nvar FileTransfer = function() {\n    this._id = ++idCounter;\n    this.onprogress = null; // optional callback\n};\n\n/**\n * Given an absolute file path, uploads a file on the device to a remote server\n * using a multipart HTTP request.\n * @param filePath {String}           Full path of the file on the device\n * @param server {String}             URL of the server to receive the file\n * @param successCallback (Function}  Callback to be invoked when upload has completed\n * @param errorCallback {Function}    Callback to be invoked upon error\n * @param options {FileUploadOptions} Optional parameters such as file name and mimetype\n * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n */\nFileTransfer.prototype.upload = function(filePath, server, successCallback, errorCallback, options) {\n    // check for arguments\n    argscheck.checkArgs('ssFFO*', 'FileTransfer.upload', arguments);\n\n    // Check if target URL doesn't contain spaces. If contains, it should be escaped first\n    // (see https://github.com/apache/cordova-plugin-file-transfer/blob/master/doc/index.md#upload)\n    if (!checkURL(server)) {\n        if (errorCallback) {\n            errorCallback(new FileTransferError(FileTransferError.INVALID_URL_ERR, filePath, server));\n        }\n        return;\n    }\n\n    options = options || {};\n\n    var fileKey = options.fileKey || \"file\";\n    var fileName = options.fileName || \"image.jpg\";\n    var mimeType = options.mimeType || \"image/jpeg\";\n    var params = options.params || {};\n    var withCredentials = options.withCredentials || false;\n    // var chunkedMode = !!options.chunkedMode; // Not supported\n    var headers = options.headers || {};\n    var httpMethod = options.httpMethod && options.httpMethod.toUpperCase() === \"PUT\" ? \"PUT\" : \"POST\";\n\n    var basicAuthHeader = getBasicAuthHeader(server);\n    if (basicAuthHeader) {\n        server = server.replace(getUrlCredentials(server) + '@', '');\n        headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    var that = this;\n    var xhr = transfers[this._id] = new XMLHttpRequest();\n    xhr.withCredentials = withCredentials;\n\n    var fail = errorCallback && function(code, status, response) {\n        if (transfers[this._id]) {\n            delete transfers[this._id];\n        }\n        var error = new FileTransferError(code, filePath, server, status, response);\n        if (errorCallback) {\n            errorCallback(error);\n        }\n    };\n\n    window.resolveLocalFileSystemURL(filePath, function(entry) {\n        entry.file(function(file) {\n            var reader = new FileReader();\n            reader.onloadend = function() {\n                var blob = new Blob([this.result], {type: mimeType});\n\n                // Prepare form data to send to server\n                var fd = new FormData();\n                fd.append(fileKey, blob, fileName);\n                for (var prop in params) {\n                    if (params.hasOwnProperty(prop)) {\n                        fd.append(prop, params[prop]);\n                    }\n                }\n\n                xhr.open(httpMethod, server);\n\n                // Fill XHR headers\n                for (var header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header, headers[header]);\n                    }\n                }\n\n                xhr.onload = function() {\n                    if (this.status === 200) {\n                        var result = new FileUploadResult(); // jshint ignore:line\n                        result.bytesSent = blob.size;\n                        result.responseCode = this.status;\n                        result.response = this.response;\n                        delete transfers[that._id];\n                        successCallback(result);\n                    } else if (this.status === 404) {\n                        fail(FileTransferError.INVALID_URL_ERR, this.status, this.response);\n                    } else {\n                        fail(FileTransferError.CONNECTION_ERR, this.status, this.response);\n                    }\n                };\n\n                xhr.ontimeout = function() {\n                    fail(FileTransferError.CONNECTION_ERR, this.status, this.response);\n                };\n\n                xhr.onerror = function() {\n                    fail(FileTransferError.CONNECTION_ERR, this.status, this.response);\n                };\n\n                xhr.onabort = function () {\n                    fail(FileTransferError.ABORT_ERR, this.status, this.response);\n                };\n\n                xhr.upload.onprogress = function (e) {\n                    if (that.onprogress) {\n                        that.onprogress(e);\n                    }\n                };\n\n                xhr.send(fd);\n                // Special case when transfer already aborted, but XHR isn't sent.\n                // In this case XHR won't fire an abort event, so we need to check if transfers record\n                // isn't deleted by filetransfer.abort and if so, call XHR's abort method again\n                if (!transfers[that._id]) {\n                    xhr.abort();\n                }\n            };\n            reader.readAsArrayBuffer(file);\n        }, function() {\n            fail(FileTransferError.FILE_NOT_FOUND_ERR);\n        });\n    }, function() {\n        fail(FileTransferError.FILE_NOT_FOUND_ERR);\n    });\n};\n\n/**\n * Downloads a file form a given URL and saves it to the specified directory.\n * @param source {String}          URL of the server to receive the file\n * @param target {String}         Full path of the file on the device\n * @param successCallback (Function}  Callback to be invoked when upload has completed\n * @param errorCallback {Function}    Callback to be invoked upon error\n * @param trustAllHosts {Boolean} Optional trust all hosts (e.g. for self-signed certs), defaults to false\n * @param options {FileDownloadOptions} Optional parameters such as headers\n */\nFileTransfer.prototype.download = function(source, target, successCallback, errorCallback, trustAllHosts, options) {\n    argscheck.checkArgs('ssFF*', 'FileTransfer.download', arguments);\n\n    // Check if target URL doesn't contain spaces. If contains, it should be escaped first\n    // (see https://github.com/apache/cordova-plugin-file-transfer/blob/master/doc/index.md#download)\n    if (!checkURL(source)) {\n        if (errorCallback) {\n            errorCallback(new FileTransferError(FileTransferError.INVALID_URL_ERR, source, target));\n        }\n        return;\n    }\n\n    options = options || {};\n    \n    var headers = options.headers || {};\n    var withCredentials = options.withCredentials || false;\n\n    var basicAuthHeader = getBasicAuthHeader(source);\n    if (basicAuthHeader) {\n        source = source.replace(getUrlCredentials(source) + '@', '');\n        headers[basicAuthHeader.name] = basicAuthHeader.value;\n    }\n\n    var that = this;\n    var xhr = transfers[this._id] = new XMLHttpRequest();\n    xhr.withCredentials = withCredentials;\n    var fail = errorCallback && function(code, status, response) {\n        if (transfers[that._id]) {\n            delete transfers[that._id];\n        }\n        // In XHR GET reqests we're setting response type to Blob\n        // but in case of error we need to raise event with plain text response\n        if (response instanceof Blob) {\n            var reader = new FileReader();\n            reader.readAsText(response);\n            reader.onloadend = function(e) {\n                var error = new FileTransferError(code, source, target, status, e.target.result);\n                errorCallback(error);\n            };\n        } else {\n            var error = new FileTransferError(code, source, target, status, response);\n            errorCallback(error);\n        }\n    };\n\n    xhr.onload = function (e) {\n\n        var fileNotFound = function () {\n            fail(FileTransferError.FILE_NOT_FOUND_ERR);\n        };\n\n        var req = e.target;\n        // req.status === 0 is special case for local files with file:// URI scheme\n        if ((req.status === 200 || req.status === 0) && req.response) {\n            window.resolveLocalFileSystemURL(getParentPath(target), function (dir) {\n                dir.getFile(getFileName(target), {create: true}, function writeFile(entry) {\n                    entry.createWriter(function (fileWriter) {\n                        fileWriter.onwriteend = function (evt) {\n                            if (!evt.target.error) {\n                                entry.filesystemName = entry.filesystem.name;\n                                delete transfers[that._id];\n                                if (successCallback) {\n                                    successCallback(entry);\n                                }\n                            } else {\n                                fail(FileTransferError.FILE_NOT_FOUND_ERR);\n                            }\n                        };\n                        fileWriter.onerror = function () {\n                            fail(FileTransferError.FILE_NOT_FOUND_ERR);\n                        };\n                        fileWriter.write(req.response);\n                    }, fileNotFound);\n                }, fileNotFound);\n            }, fileNotFound);\n        } else if (req.status === 404) {\n            fail(FileTransferError.INVALID_URL_ERR, req.status, req.response);\n        } else {\n            fail(FileTransferError.CONNECTION_ERR, req.status, req.response);\n        }\n    };\n\n    xhr.onprogress = function (e) {\n        if (that.onprogress) {\n            that.onprogress(e);\n        }\n    };\n\n    xhr.onerror = function () {\n        fail(FileTransferError.CONNECTION_ERR, this.status, this.response);\n    };\n\n    xhr.onabort = function () {\n        fail(FileTransferError.ABORT_ERR, this.status, this.response);\n    };\n\n    xhr.open(\"GET\", source, true);\n\n    for (var header in headers) {\n        if (headers.hasOwnProperty(header)) {\n            xhr.setRequestHeader(header, headers[header]);\n        }\n    }\n\n    xhr.responseType = \"blob\";\n\n    xhr.send();\n};\n\n/**\n * Aborts the ongoing file transfer on this object. The original error\n * callback for the file transfer will be called if necessary.\n */\nFileTransfer.prototype.abort = function() {\n    if (this instanceof FileTransfer) {\n        if (transfers[this._id]) {\n            transfers[this._id].abort();\n            delete transfers[this._id];\n        }\n    }\n};\n\nmodule.exports = FileTransfer;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/firefoxos/FileTransferProxy.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\nvar FileTransferError = require('./FileTransferError'),\n    xhr = {};\n\nfunction getParentPath(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(0, pos + 1);\n}\n\nfunction getFileName(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(pos + 1);\n}\n\nmodule.exports = {\n    abort: function (successCallback, errorCallback, args) {\n        var id = args[0];\n        if (xhr[id]) {\n            xhr[id].abort();\n            if (typeof(successCallback) === 'function') {\n                successCallback();\n            }\n        } else if (typeof(errorCallback) === 'function') {\n            errorCallback();\n        }\n    },\n\n    upload: function(successCallback, errorCallback, args) {\n        var filePath = args[0],\n            server = args[1],\n            fileKey = args[2],\n            fileName = args[3],\n            mimeType = args[4],\n            params = args[5],\n            /*trustAllHosts = args[6],*/\n            /*chunkedMode = args[7],*/\n            headers = args[8];\n\n        xhr[fileKey] = new XMLHttpRequest({mozSystem: true});\n        xhr[fileKey].onabort = function() {\n            onFail(new FileTransferError(FileTransferError.ABORT_ERR, server, filePath, this.status, xhr[fileKey].response));\n        };\n\n        window.resolveLocalFileSystemURL(filePath, function(entry) {\n            entry.file(function(file) {\n                var reader = new FileReader();\n\n                reader.onloadend = function() {\n                    var blob = new Blob([this.result], {type: mimeType});\n                    var fd = new FormData();\n\n                    fd.append(fileKey, blob, fileName);\n\n                    for (var prop in params) {\n                        if (params.hasOwnProperty(prop)) {\n                            fd.append(prop, params[prop]);\n                        }\n                    }\n\n                    xhr[fileKey].open(\"POST\", server);\n\n                    xhr[fileKey].onload = function(evt) {\n                        if (xhr[fileKey].status === 200) {\n                            var result = new FileUploadResult();\n                            result.bytesSent = blob.size;\n                            result.responseCode = xhr[fileKey].status;\n                            result.response = xhr[fileKey].response;\n                            delete xhr[fileKey];\n                            onSuccess(result);\n                        } else if (xhr[fileKey].status === 404) {\n                            onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                        } else {\n                            onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                        }\n                    };\n\n                    xhr[fileKey].ontimeout = function() {\n                        onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, xhr[fileKey].status, xhr[fileKey].response));\n                    };\n\n                    xhr[fileKey].onerror = function() {\n                        onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, server, filePath, this.status, xhr[fileKey].response));\n                    };\n\n                    for (var header in headers) {\n                        if (headers.hasOwnProperty(header)) {\n                            xhr[fileKey].setRequestHeader(header, headers[header]);\n                        }\n                    }\n\n                    xhr[fileKey].send(fd);\n                };\n\n                reader.readAsArrayBuffer(file);\n\n            }, function() {\n                onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, server, filePath));\n            });\n        }, function() {\n            onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, server, filePath));\n        });\n\n        function onSuccess(data) {\n            if (typeof(successCallback) === 'function') {\n                successCallback(data);\n            }\n        }\n\n        function onFail(code) {\n            delete xhr[fileKey];\n            if (typeof(errorCallback) === 'function') {\n                errorCallback(code);\n            }\n        }\n    },\n\n    download: function (successCallback, errorCallback, args) {\n        var source = args[0],\n            target = args[1],\n            id = args[3],\n            headers = args[4];\n\n        xhr[id] = new XMLHttpRequest({mozSystem: true});\n\n        xhr[id].onload = function () {\n            if (xhr[id].readyState === xhr[id].DONE) {\n                if (xhr[id].status === 200 && xhr[id].response) {\n                    window.resolveLocalFileSystemURL(getParentPath(target), function (dir) {\n                        dir.getFile(getFileName(target), {create: true}, writeFile, function (error) {\n                            onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, source, target, xhr[id].status, xhr[id].response));\n                        });\n                    }, function () {\n                        onFail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR, source, target, xhr[id].status, xhr[id].response));\n                    });\n                } else if (xhr[id].status === 404) {\n                    onFail(new FileTransferError(FileTransferError.INVALID_URL_ERR, source, target, xhr[id].status, xhr[id].response));\n                } else {\n                    onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, source, target, xhr[id].status, xhr[id].response));\n                }\n            }\n        };\n\n        function writeFile(entry) {\n            entry.createWriter(function (fileWriter) {\n                fileWriter.onwriteend = function (evt) {\n                    if (!evt.target.error) {\n                        entry.filesystemName = entry.filesystem.name;\n                        delete xhr[id];\n                        onSuccess(entry);\n                    } else {\n                        onFail(evt.target.error);\n                    }\n                };\n                fileWriter.onerror = function (evt) {\n                    onFail(evt.target.error);\n                };\n                fileWriter.write(new Blob([xhr[id].response]));\n            }, function (error) {\n                onFail(error);\n            });\n        }\n\n        xhr[id].onerror = function (e) {\n            onFail(new FileTransferError(FileTransferError.CONNECTION_ERR, source, target, xhr[id].status, xhr[id].response));\n        };\n\n        xhr[id].onabort = function (e) {\n            onFail(new FileTransferError(FileTransferError.ABORT_ERR, source, target, xhr[id].status, xhr[id].response));\n        };\n\n        xhr[id].open(\"GET\", source, true);\n\n        for (var header in headers) {\n            if (headers.hasOwnProperty(header)) {\n                xhr[id].setRequestHeader(header, headers[header]);\n            }\n        }\n\n        xhr[id].responseType = \"blob\";\n\n        setTimeout(function () {\n            if (xhr[id]) {\n                xhr[id].send();\n            }\n        }, 0);\n\n        function onSuccess(entry) {\n            if (typeof(successCallback) === 'function') {\n                successCallback(entry);\n            }\n        }\n\n        function onFail(error) {\n            delete xhr[id];\n            if (typeof(errorCallback) === 'function') {\n                errorCallback(error);\n            }\n        }\n    }\n};\n\nrequire('cordova/exec/proxy').add('FileTransfer', module.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-file-transfer/node_modules/cordova-plugin-file-transfer/www/wp7/base64.js":"/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n*/\n\n// jshint ignore: start\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n    INVALID_CHARACTER_ERR = (function () {\n        // fabricate a suitable error object\n        try { document.createElement('$'); }\n        catch (error) { return error; }\n    }());\n\n    // encoder\n    // [https://gist.github.com/999166] by [https://github.com/nignag]\n    window.btoa || (\n    window.btoa = function (input) {\n        for (\n            // initialize result and counter\n          var block, charCode, idx = 0, map = chars, output = '';\n            // if the next input index does not exist:\n            //   change the mapping table to \"=\"\n            //   check if d has no fractional digits\n          input.charAt(idx | 0) || (map = '=', idx % 1) ;\n            // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n          output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = input.charCodeAt(idx += 3 / 4);\n            if (charCode > 0xFF) throw INVALID_CHARACTER_ERR;\n            block = block << 8 | charCode;\n        }\n        return output;\n    });\n\n    // decoder\n    // [https://gist.github.com/1020396] by [https://github.com/atk]\n    window.atob || (\n    window.atob = function (input) {\n        input = input.replace(/=+$/, '')\n        if (input.length % 4 == 1) throw INVALID_CHARACTER_ERR;\n        for (\n            // initialize result and counters\n          var bc = 0, bs, buffer, idx = 0, output = '';\n            // get next character\n          buffer = input.charAt(idx++) ;\n            // character found in table? initialize bit storage and add its ascii value;\n          ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    });"}